// Code generated by protoc-gen-go. DO NOT EDIT.
// source: chat.proto

/*
Package chat is a generated protocol buffer package.

It is generated from these files:
	chat.proto

It has these top-level messages:
	TalkingWords
	TalkingLength
	SendingResponse
*/
package chat

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TalkingWords struct {
	Words string `protobuf:"bytes,1,opt,name=words" json:"words,omitempty"`
}

func (m *TalkingWords) Reset()                    { *m = TalkingWords{} }
func (m *TalkingWords) String() string            { return proto.CompactTextString(m) }
func (*TalkingWords) ProtoMessage()               {}
func (*TalkingWords) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TalkingWords) GetWords() string {
	if m != nil {
		return m.Words
	}
	return ""
}

type TalkingLength struct {
	Length int32 `protobuf:"varint,1,opt,name=length" json:"length,omitempty"`
}

func (m *TalkingLength) Reset()                    { *m = TalkingLength{} }
func (m *TalkingLength) String() string            { return proto.CompactTextString(m) }
func (*TalkingLength) ProtoMessage()               {}
func (*TalkingLength) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TalkingLength) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type SendingResponse struct {
	Words string `protobuf:"bytes,1,opt,name=words" json:"words,omitempty"`
}

func (m *SendingResponse) Reset()                    { *m = SendingResponse{} }
func (m *SendingResponse) String() string            { return proto.CompactTextString(m) }
func (*SendingResponse) ProtoMessage()               {}
func (*SendingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SendingResponse) GetWords() string {
	if m != nil {
		return m.Words
	}
	return ""
}

func init() {
	proto.RegisterType((*TalkingWords)(nil), "chat.TalkingWords")
	proto.RegisterType((*TalkingLength)(nil), "chat.TalkingLength")
	proto.RegisterType((*SendingResponse)(nil), "chat.SendingResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Sending service

type SendingClient interface {
	Run(ctx context.Context, opts ...grpc.CallOption) (Sending_RunClient, error)
}

type sendingClient struct {
	cc *grpc.ClientConn
}

func NewSendingClient(cc *grpc.ClientConn) SendingClient {
	return &sendingClient{cc}
}

func (c *sendingClient) Run(ctx context.Context, opts ...grpc.CallOption) (Sending_RunClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Sending_serviceDesc.Streams[0], c.cc, "/chat.Sending/Run", opts...)
	if err != nil {
		return nil, err
	}
	x := &sendingRunClient{stream}
	return x, nil
}

type Sending_RunClient interface {
	Send(*TalkingWords) error
	CloseAndRecv() (*TalkingLength, error)
	grpc.ClientStream
}

type sendingRunClient struct {
	grpc.ClientStream
}

func (x *sendingRunClient) Send(m *TalkingWords) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sendingRunClient) CloseAndRecv() (*TalkingLength, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(TalkingLength)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Sending service

type SendingServer interface {
	Run(Sending_RunServer) error
}

func RegisterSendingServer(s *grpc.Server, srv SendingServer) {
	s.RegisterService(&_Sending_serviceDesc, srv)
}

func _Sending_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SendingServer).Run(&sendingRunServer{stream})
}

type Sending_RunServer interface {
	SendAndClose(*TalkingLength) error
	Recv() (*TalkingWords, error)
	grpc.ServerStream
}

type sendingRunServer struct {
	grpc.ServerStream
}

func (x *sendingRunServer) SendAndClose(m *TalkingLength) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sendingRunServer) Recv() (*TalkingWords, error) {
	m := new(TalkingWords)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Sending_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.Sending",
	HandlerType: (*SendingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _Sending_Run_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "chat.proto",
}

// Client API for Receiving service

type ReceivingClient interface {
	Run(ctx context.Context, in *TalkingLength, opts ...grpc.CallOption) (Receiving_RunClient, error)
}

type receivingClient struct {
	cc *grpc.ClientConn
}

func NewReceivingClient(cc *grpc.ClientConn) ReceivingClient {
	return &receivingClient{cc}
}

func (c *receivingClient) Run(ctx context.Context, in *TalkingLength, opts ...grpc.CallOption) (Receiving_RunClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Receiving_serviceDesc.Streams[0], c.cc, "/chat.Receiving/Run", opts...)
	if err != nil {
		return nil, err
	}
	x := &receivingRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Receiving_RunClient interface {
	Recv() (*TalkingWords, error)
	grpc.ClientStream
}

type receivingRunClient struct {
	grpc.ClientStream
}

func (x *receivingRunClient) Recv() (*TalkingWords, error) {
	m := new(TalkingWords)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Receiving service

type ReceivingServer interface {
	Run(*TalkingLength, Receiving_RunServer) error
}

func RegisterReceivingServer(s *grpc.Server, srv ReceivingServer) {
	s.RegisterService(&_Receiving_serviceDesc, srv)
}

func _Receiving_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TalkingLength)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReceivingServer).Run(m, &receivingRunServer{stream})
}

type Receiving_RunServer interface {
	Send(*TalkingWords) error
	grpc.ServerStream
}

type receivingRunServer struct {
	grpc.ServerStream
}

func (x *receivingRunServer) Send(m *TalkingWords) error {
	return x.ServerStream.SendMsg(m)
}

var _Receiving_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.Receiving",
	HandlerType: (*ReceivingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _Receiving_Run_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "chat.proto",
}

// Client API for Talking service

type TalkingClient interface {
	Run(ctx context.Context, opts ...grpc.CallOption) (Talking_RunClient, error)
}

type talkingClient struct {
	cc *grpc.ClientConn
}

func NewTalkingClient(cc *grpc.ClientConn) TalkingClient {
	return &talkingClient{cc}
}

func (c *talkingClient) Run(ctx context.Context, opts ...grpc.CallOption) (Talking_RunClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Talking_serviceDesc.Streams[0], c.cc, "/chat.Talking/Run", opts...)
	if err != nil {
		return nil, err
	}
	x := &talkingRunClient{stream}
	return x, nil
}

type Talking_RunClient interface {
	Send(*TalkingWords) error
	Recv() (*TalkingWords, error)
	grpc.ClientStream
}

type talkingRunClient struct {
	grpc.ClientStream
}

func (x *talkingRunClient) Send(m *TalkingWords) error {
	return x.ClientStream.SendMsg(m)
}

func (x *talkingRunClient) Recv() (*TalkingWords, error) {
	m := new(TalkingWords)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Talking service

type TalkingServer interface {
	Run(Talking_RunServer) error
}

func RegisterTalkingServer(s *grpc.Server, srv TalkingServer) {
	s.RegisterService(&_Talking_serviceDesc, srv)
}

func _Talking_Run_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TalkingServer).Run(&talkingRunServer{stream})
}

type Talking_RunServer interface {
	Send(*TalkingWords) error
	Recv() (*TalkingWords, error)
	grpc.ServerStream
}

type talkingRunServer struct {
	grpc.ServerStream
}

func (x *talkingRunServer) Send(m *TalkingWords) error {
	return x.ServerStream.SendMsg(m)
}

func (x *talkingRunServer) Recv() (*TalkingWords, error) {
	m := new(TalkingWords)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Talking_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chat.Talking",
	HandlerType: (*TalkingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Run",
			Handler:       _Talking_Run_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "chat.proto",
}

func init() { proto.RegisterFile("chat.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 192 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4a, 0xce, 0x48, 0x2c,
	0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x01, 0xb1, 0x95, 0x54, 0xb8, 0x78, 0x42, 0x12,
	0x73, 0xb2, 0x33, 0xf3, 0xd2, 0xc3, 0xf3, 0x8b, 0x52, 0x8a, 0x85, 0x44, 0xb8, 0x58, 0xcb, 0x41,
	0x0c, 0x09, 0x46, 0x05, 0x46, 0x0d, 0xce, 0x20, 0x08, 0x47, 0x49, 0x9d, 0x8b, 0x17, 0xaa, 0xca,
	0x27, 0x35, 0x2f, 0xbd, 0x24, 0x43, 0x48, 0x8c, 0x8b, 0x2d, 0x07, 0xcc, 0x02, 0xab, 0x63, 0x0d,
	0x82, 0xf2, 0x94, 0xd4, 0xb9, 0xf8, 0x83, 0x53, 0xf3, 0x52, 0x32, 0xf3, 0xd2, 0x83, 0x52, 0x8b,
	0x0b, 0xf2, 0xf3, 0x8a, 0x53, 0xb1, 0x9b, 0x68, 0x64, 0xcb, 0xc5, 0x0e, 0x55, 0x28, 0x64, 0xc4,
	0xc5, 0x1c, 0x54, 0x9a, 0x27, 0x24, 0xa4, 0x07, 0x76, 0x1c, 0xb2, 0x6b, 0xa4, 0x84, 0x51, 0xc4,
	0x20, 0x76, 0x2b, 0x31, 0x68, 0x30, 0x1a, 0xd9, 0x73, 0x71, 0x06, 0xa5, 0x26, 0xa7, 0x66, 0x96,
	0x21, 0x19, 0x80, 0x4d, 0xb1, 0x14, 0x16, 0x53, 0x95, 0x18, 0x0c, 0x18, 0x8d, 0xec, 0xb8, 0xd8,
	0xa1, 0x62, 0x42, 0xc6, 0xb8, 0xed, 0xc7, 0xaa, 0x5b, 0x83, 0xd1, 0x80, 0x31, 0x89, 0x0d, 0x1c,
	0x88, 0xc6, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf3, 0xf7, 0x1f, 0xd5, 0x52, 0x01, 0x00, 0x00,
}
